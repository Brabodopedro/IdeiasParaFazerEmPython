pip install flask twilio pandas openpyxl

ngrok config add-authtoken 2odDu4pqF56M3e0WbcMb5EkRvcL_6jb46Ad71MWgYg1EVu9sR

ngrok http 5000



p/ rodar :

1- flask run
2- ngrok http 5000

postman:curl -X POST http://127.0.0.1:5000/bot -d "Body=iphone" -d "From=whatsapp:+SEU_NUMERO"



import json
import requests
import pandas as pd  # Importa pandas para manipular a planilha Excel
import os  # Para verificar a existência de arquivos
import logging  # Para registrar logs

# Definindo o caminho para o arquivo de estados de conversa
STATE_FILE = 'conversation_states.json'

class ultraChatBot():
    def __init__(self, message_data):
        self.message = message_data
        self.chatID = message_data.get('from')  # Obtém o ID do chat
        self.ultraAPIUrl = 'https://api.ultramsg.com/instance99723/'
        self.token = '2str21gem9r5za4u'
        # Carrega os estados das conversas
        self.states = self.load_states()
       
    # Método para carregar os estados das conversas
    def load_states(self):
        if os.path.exists(STATE_FILE):
            with open(STATE_FILE, 'r') as f:
                return json.load(f)
        else:
            return {}
    
    # Método para salvar os estados das conversas
    def save_states(self):
        with open(STATE_FILE, 'w') as f:
            json.dump(self.states, f)
       
    # Método genérico para enviar requisições à API
    def send_requests(self, type, data):
        url = f"{self.ultraAPIUrl}{type}?token={self.token}"
        headers = {'Content-type': 'application/json'}
        answer = requests.post(url, data=json.dumps(data), headers=headers)
        return answer.json()

    # Método para enviar uma mensagem de texto
    def send_message(self, chatID, text):
        data = {
            "to": chatID,
            "body": text
        }
        answer = self.send_requests('messages/chat', data)
        return answer

    # Método para enviar a saudação inicial e perguntar pelo modelo
    def greet_and_ask_model(self):
        greeting = "Olá! Bem-vindo à nossa loja de celulares."
        question = "Qual modelo de celular você está procurando?"
        self.send_message(self.chatID, greeting)
        self.send_message(self.chatID, question)
        # Atualiza o estado para 'ASKED_MODEL'
        self.states[self.chatID] = 'ASKED_MODEL'
        self.save_states()

    # Método para pesquisar o modelo na planilha
    def search_and_send_model_info(self, model_name):
        try:
            # Lê a planilha Excel
            df = pd.read_excel('ESTOQUE_.xlsx')

            # Remover espaços dos nomes das colunas
            df.columns = df.columns.str.strip()

            # Normalizar os nomes das colunas (remover acentos e colocar em minúsculas)
            from unidecode import unidecode
            df.columns = [unidecode(col).lower() for col in df.columns]

            # Log dos nomes das colunas para verificar
            logging.info(f"Colunas do DataFrame: {df.columns}")

            # Use os nomes normalizados das colunas
            resultados = df[df['modelo'].str.contains(model_name, case=False, na=False)]

            if not resultados.empty:
                # Prepara a mensagem com os detalhes dos celulares encontrados
                mensagem = "Encontramos os seguintes modelos:\n"
                for index, row in resultados.iterrows():
                    modelo = row['modelo']
                    cor = row['cor']
                    condicao = row['condicao']
                    valor = row['valor']
                    mensagem += f"- Modelo: {modelo}, Cor: {cor}, Condição: {condicao}, Valor: R${valor}\n"
                self.send_message(self.chatID, mensagem)
                # Atualiza o estado
                self.states[self.chatID] = 'FINISHED'
                self.save_states()
            else:
                # Se não encontrar nenhum resultado
                self.send_message(self.chatID, "Desculpe, não encontramos esse modelo em nosso estoque.")
                # Mantém o estado em 'ASKED_MODEL' para permitir que o cliente tente novamente
                self.states[self.chatID] = 'ASKED_MODEL'
                self.save_states()
        except Exception as e:
            logging.error(f"Erro ao ler a planilha: {e}")
            self.send_message(self.chatID, "Desculpe, ocorreu um erro ao buscar o modelo.")
            # Resetar o estado
            self.states[self.chatID] = 'ASKED_MODEL'
            self.save_states()


    # Método para processar as mensagens recebidas
    def Processingـincomingـmessages(self):
        message = self.message
        if message:
            if 'body' in message and 'from' in message:
                text = message['body'].strip()
                if not message['fromMe']:
                    # Verifica o estado atual do cliente
                    state = self.states.get(self.chatID, 'INITIAL')
                    if state == 'INITIAL':
                        # Saudação inicial e pergunta pelo modelo
                        self.greet_and_ask_model()
                        return 'Greeted and asked for model'
                    elif state == 'ASKED_MODEL':
                        # O cliente respondeu com o modelo
                        model_name = text
                        self.search_and_send_model_info(model_name)
                        return 'Searched and sent model info'
                    elif state == 'FINISHED':
                        # Conversa finalizada, pode optar por reiniciar ou agradecer
                        self.send_message(self.chatID, "Posso ajudar em algo mais?")
                        # Resetar o estado para 'ASKED_MODEL' para continuar a conversa
                        self.states[self.chatID] = 'ASKED_MODEL'
                        self.save_states()
                        return 'Asked if need more help'
                    else:
                        # Estado desconhecido, resetar para 'INITIAL'
                        self.states[self.chatID] = 'INITIAL'
                        self.save_states()
                        self.greet_and_ask_model()
                        return 'Reset state and greeted'
                else:
                    return 'No action for messages sent by bot'
            else:
                logging.error("Faltando 'body' ou 'from' nos dados da mensagem.")
                return 'Erro: Dados da mensagem incompletos'
        else:
            return 'Nenhuma mensagem para processar'
